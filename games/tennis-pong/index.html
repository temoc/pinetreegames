<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tennis Court Pong</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #2d5016;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameContainer {
            text-align: center;
        }

        canvas {
            border: 4px solid #fff;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            background: #2d5016;
            max-width: 100%;
            height: auto;
        }

        #score {
            color: #fff;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 40px;
            font-weight: bold;
        }

        #instructions {
            color: #fff;
            font-size: 16px;
            margin-top: 20px;
            text-shadow: 2px 2px 4px #000;
        }

        .desktop-instructions {
            display: inline;
        }

        .mobile-instructions {
            display: none;
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 36px;
            text-shadow: 3px 3px 6px #000;
            text-align: center;
        }

        #gameOver.show {
            display: block;
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Distraction popup styles */
        .distraction {
            position: fixed;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 1000;
            pointer-events: none;
            animation: distractPop 3s ease-in-out forwards;
        }

        @keyframes distractPop {
            0% {
                opacity: 0;
                transform: scale(0.5) rotate(-10deg);
            }
            10% {
                opacity: 1;
                transform: scale(1.2) rotate(5deg);
            }
            20% {
                transform: scale(1) rotate(-2deg);
            }
            80% {
                opacity: 1;
                transform: scale(1) rotate(2deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) rotate(10deg);
            }
        }

        /* Mobile touch controls */
        .touch-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }

        .paddle-controls {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .touch-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid #fff;
            border-radius: 15px;
            color: #fff;
            font-size: 32px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            backdrop-filter: blur(10px);
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        /* Mobile responsive styles */
        @media (max-width: 900px) {
            body {
                padding: 10px;
            }

            #score {
                font-size: 32px;
                letter-spacing: 20px;
                margin-bottom: 10px;
            }

            #instructions {
                font-size: 12px;
                margin-top: 10px;
            }

            .desktop-instructions {
                display: none;
            }

            .mobile-instructions {
                display: inline;
            }

            .touch-controls {
                display: flex;
            }

            .distraction {
                font-size: 18px;
                padding: 12px 20px;
            }

            #gameOver {
                font-size: 24px;
                padding: 20px;
            }
        }

        @media (max-width: 500px) {
            #score {
                font-size: 24px;
                letter-spacing: 10px;
            }

            #instructions {
                font-size: 10px;
            }

            .touch-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }

            .distraction {
                font-size: 14px;
                padding: 8px 15px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">0 : 0</div>
        <canvas id="pongCanvas" width="800" height="600"></canvas>
        <div id="instructions">
            <span class="desktop-instructions">W/S - Left Racquet | P/L - Right Racquet | SPACE - Start/Pause</span>
            <span class="mobile-instructions">Touch screen to start | Use buttons below to move paddles</span>
        </div>
        <div id="gameOver">
            <div id="winnerText"></div>
            <div style="font-size: 20px; margin-top: 20px;" class="blink">Press SPACE to Play Again</div>
        </div>
    </div>

    <!-- Mobile touch controls -->
    <div class="touch-controls">
        <div class="paddle-controls" id="leftControls">
            <button class="touch-btn" id="leftUp">â–²</button>
            <button class="touch-btn" id="leftDown">â–¼</button>
        </div>
        <div class="paddle-controls" id="rightControls">
            <button class="touch-btn" id="rightUp">â–²</button>
            <button class="touch-btn" id="rightDown">â–¼</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const gameOverDisplay = document.getElementById('gameOver');
        const winnerText = document.getElementById('winnerText');

        // Game state
        let gameRunning = false;
        let gameStarted = false;

        // Detect mobile for scaling
        const isMobile = window.innerWidth <= 900;
        const mobileScale = isMobile ? 2 : 1;  // 2x bigger on mobile

        // Racquet properties (tennis racquet shape)
        const racquetWidth = 15 * mobileScale;
        const racquetHeight = 70 * mobileScale;  // Bigger on mobile
        const racquetSpeed = 9;     // Faster movement

        const leftRacquet = {
            x: 20,
            y: canvas.height / 2 - racquetHeight / 2,
            width: racquetWidth,
            height: racquetHeight,
            dy: 0
        };

        const rightRacquet = {
            x: canvas.width - 20 - racquetWidth,
            y: canvas.height / 2 - racquetHeight / 2,
            width: racquetWidth,
            height: racquetHeight,
            dy: 0
        };

        // Tennis ball properties
        const ballRadius = 8 * mobileScale;  // 2x bigger on mobile
        const initialSpeed = 4;  // Start slow
        const maxSpeed = 20;     // Build up to insane speed
        const speedIncrement = 0.3;  // Gradual speed increase per hit
        let ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            dx: initialSpeed,
            dy: initialSpeed,
            speed: initialSpeed,
            rotation: 0
        };

        // Tennis scoring system
        let leftPoints = 0;  // 0, 15, 30, 40, advantage
        let rightPoints = 0;
        let leftGames = 0;
        let rightGames = 0;
        const winningGames = 3;  // First to 3 games wins the match

        // Distraction system
        let lastDistractionTime = 0;
        const distractionInterval = 8000; // Show distraction every 8 seconds minimum

        const distractions = [
            // SAVAGE skill-based taunts
            { text: "Did you skip practice? ALL of it? ðŸ˜¤", color: "#ff6b6b", side: "random" },
            { text: "This is embarrassing to watch ðŸ«£", color: "#ff4757", side: "random" },
            { text: "Maybe try a sport that's easier? Like napping? ðŸ˜´", color: "#ffd93d", side: "random" },
            { text: "PATHETIC excuse for a shot! ðŸ’€", color: "#ff6348", side: "random" },
            { text: "Your paddle has trust issues now ðŸŽ¾ðŸ’”", color: "#fd79a8", side: "random" },
            { text: "Did you practice with your eyes closed?! ðŸ™ˆ", color: "#a29bfe", side: "random" },
            { text: "That was slower than a sloth on vacation ðŸ¦¥", color: "#6bcf7f", side: "random" },
            { text: "Is this your first time holding a racquet? ðŸ¤”", color: "#74b9ff", side: "random" },
            { text: "Even pickleball players are embarrassed ðŸ¥’", color: "#00b894", side: "random" },
            { text: "You call that a swing?! I call it a crime! ðŸ‘®", color: "#ff7675", side: "random" },
            { text: "Pro tip: HIT THE BALL ðŸŽ¯", color: "#ffd93d", side: "random" },
            { text: "My dead battery has more energy than that ðŸ”‹ðŸ’€", color: "#636e72", side: "random" },
            { text: "Are you allergic to winning? ðŸ¤§", color: "#ff6b6b", side: "random" },
            { text: "This is painful to watch ðŸ˜¬", color: "#e17055", side: "random" },
            { text: "Did you buy your skills on wish.com? ðŸ›’", color: "#a29bfe", side: "random" },
            { text: "UNINSTALL YOUR REFLEXES ðŸ—‘ï¸", color: "#ff4757", side: "random" },
            { text: "YouTube tutorial recommended ðŸ“º", color: "#74b9ff", side: "random" },
            { text: "Hand-eye coordination NOT FOUND 404 ðŸš«", color: "#636e72", side: "random" },
            { text: "Maybe stick to watching tennis? ðŸ“º", color: "#ffeaa7", side: "random" },
            { text: "That shot had NEGATIVE power ðŸ“‰", color: "#ff6348", side: "random" },
            { text: "Were you aiming for the parking lot? ðŸš—", color: "#00b894", side: "random" },
            { text: "Butterfingers much? ðŸ§ˆðŸ‘†", color: "#ffd93d", side: "random" },
            { text: "Your ancestors are disappointed ðŸ‘´ðŸ’­", color: "#a29bfe", side: "random" },
            { text: "This is why you have no friends ðŸš«ðŸ‘¥", color: "#ff6b6b", side: "random" },
            { text: "Zero practice = zero results ðŸ“Š", color: "#ff4757", side: "random" },
            { text: "Skill issue detected! ðŸš¨", color: "#ff6348", side: "random" },
            { text: "Have you considered retirement? ðŸ‘´", color: "#636e72", side: "random" },
            { text: "That was SAD. Actually sad. ðŸ˜¢", color: "#74b9ff", side: "random" },
            { text: "DELETE THIS PERFORMANCE ðŸ—‘ï¸", color: "#ff4757", side: "random" },
            { text: "You're the reason we can't have nice things ðŸ™„", color: "#a29bfe", side: "random" },

            // BRUTAL practice shaming
            { text: "When was your last practice? 2019?! ðŸ“…", color: "#ff6b6b", side: "random" },
            { text: "ZERO hours practiced, it shows ðŸ•", color: "#ff4757", side: "random" },
            { text: "Practice is OPTIONAL... said no champion ever ðŸ†", color: "#ffd93d", side: "random" },
            { text: "Talent? Maybe. Practice? Nope. ðŸ“‰", color: "#ff6348", side: "random" },
            { text: "That's what happens when you skip drills ðŸŽ¯", color: "#e17055", side: "random" },
            { text: "YouTube tutorials DON'T count as practice ðŸ“±", color: "#74b9ff", side: "random" },
            { text: "Couch time â‰  Court time ðŸ›‹ï¸âŒ", color: "#a29bfe", side: "random" },
            { text: "Your practice schedule: EMPTY ðŸ“…", color: "#636e72", side: "random" },
            { text: "Dedication: 0% | Excuses: 100% ðŸ“Š", color: "#ff6b6b", side: "random" },
            { text: "Winners practice. You... don't. ðŸ¤·", color: "#ff4757", side: "random" },

            // Opponent trash talk
            { text: "ðŸ˜¤ *laughing at your game*", color: "#e17055", side: "opponent" },
            { text: "ðŸ¤£ SERIOUSLY?! THAT'S IT?!", color: "#ff6348", side: "opponent" },
            { text: "ðŸ’ª I'm not even trying lol", color: "#00b894", side: "opponent" },
            { text: "ðŸ‘€ Are you okay? Need a break? ðŸ˜", color: "#a29bfe", side: "opponent" },
            { text: "ðŸŽ¾ TOO EASY! Way too easy!", color: "#00d2d3", side: "opponent" },
            { text: "ðŸ˜… This is literally free ðŸ’°", color: "#ffeaa7", side: "opponent" },
            { text: "ðŸ”¥ You're not ready for this!", color: "#ff6348", side: "opponent" },
            { text: "ðŸ’€ RIP your tennis career", color: "#636e72", side: "opponent" },
            { text: "ðŸ† MVP! ...Oh wait, that's me ðŸ˜Ž", color: "#ffd93d", side: "opponent" },
            { text: "ðŸŽ¯ Target practice with your ego ðŸŽˆ", color: "#ff4757", side: "opponent" },
            { text: "ðŸ˜¬ Second-hand embarrassment ðŸ˜°", color: "#74b9ff", side: "opponent" },
            { text: "ðŸ¤¡ *chefs kiss* PERFECTION!", color: "#fd79a8", side: "opponent" },

            // Provocative surprise elements
            { text: "âš ï¸ WARNING: Skill gap detected! ðŸ“Š", color: "#ff6348", side: "center" },
            { text: "ðŸš¨ CRINGE ALERT! CRINGE ALERT! ðŸš¨", color: "#ff4757", side: "center" },
            { text: "ðŸ“‰ Your stock is TANKING ðŸ’¹", color: "#636e72", side: "center" },
            { text: "ðŸŽª Welcome to the CIRCUS ðŸ¤¡", color: "#fd79a8", side: "center" },
            { text: "ðŸ”” SHAME! SHAME! SHAME! ðŸ””", color: "#ff6b6b", side: "center" },
            { text: "ðŸ“± Mom called: She's disappointed ðŸ˜”", color: "#74b9ff", side: "center" },
            { text: "ðŸ¦… Even birds fly away from this disaster", color: "#a29bfe", side: "center" },
            { text: "ðŸŽ¬ Netflix should NOT make a documentary of this ðŸ“¹", color: "#ffd93d", side: "center" },
            { text: "âš¡ Witness protection for that shot! ðŸ«£", color: "#ffeaa7", side: "center" },
            { text: "ðŸŒªï¸ DISASTER ZONE AHEAD! âš ï¸", color: "#ff7675", side: "center" },
            { text: "ðŸš Medical evacuation on standby ðŸ¥", color: "#e17055", side: "center" },
            { text: "ðŸ“ž Your coach is calling... to quit ðŸšª", color: "#636e72", side: "center" },
            { text: "ðŸŽ“ Enroll in Tennis School ASAP ðŸ“š", color: "#74b9ff", side: "center" },
            { text: "ðŸ³ï¸ Just surrender now, save time â°", color: "#a29bfe", side: "center" },
            { text: "ðŸŽ® Maybe stick to video games? ðŸ•¹ï¸", color: "#ffd93d", side: "center" }
        ];

        // Tennis score labels
        function getTennisScore(points) {
            const scores = ['0', '15', '30', '40'];
            return points < 4 ? scores[points] : '40';
        }

        // Show random distraction
        function showDistraction() {
            const now = Date.now();
            if (now - lastDistractionTime < distractionInterval) return;

            lastDistractionTime = now;

            const distraction = distractions[Math.floor(Math.random() * distractions.length)];
            const div = document.createElement('div');
            div.className = 'distraction';
            div.textContent = distraction.text;
            div.style.color = distraction.color;

            // Position based on side
            if (distraction.side === 'left' || (distraction.side === 'opponent' && Math.random() > 0.5)) {
                div.style.left = '10%';
                div.style.top = Math.random() * 60 + 20 + '%';
            } else if (distraction.side === 'right' || (distraction.side === 'opponent' && Math.random() <= 0.5)) {
                div.style.right = '10%';
                div.style.top = Math.random() * 60 + 20 + '%';
            } else { // center or random
                div.style.left = Math.random() * 40 + 30 + '%';
                div.style.top = Math.random() * 50 + 25 + '%';
            }

            document.body.appendChild(div);

            // Play random grunt/taunt sound
            const randomFreq = 150 + Math.random() * 200;
            playSound(randomFreq, 0.15);

            // Remove after animation
            setTimeout(() => div.remove(), 3000);
        }

        // Keyboard state
        const keys = {};

        // Touch control state
        const touchState = {
            leftUp: false,
            leftDown: false,
            rightUp: false,
            rightDown: false
        };

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key === ' ') {
                e.preventDefault();
                if (!gameStarted) {
                    startGame();
                } else if (gameOverDisplay.classList.contains('show')) {
                    resetGame();
                } else {
                    gameRunning = !gameRunning;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Touch control event listeners
        function setupTouchControls() {
            const leftUp = document.getElementById('leftUp');
            const leftDown = document.getElementById('leftDown');
            const rightUp = document.getElementById('rightUp');
            const rightDown = document.getElementById('rightDown');

            // Prevent default touch behavior
            [leftUp, leftDown, rightUp, rightDown].forEach(btn => {
                btn.addEventListener('touchstart', (e) => e.preventDefault());
            });

            // Left paddle up
            leftUp.addEventListener('touchstart', () => touchState.leftUp = true);
            leftUp.addEventListener('touchend', () => touchState.leftUp = false);
            leftUp.addEventListener('touchcancel', () => touchState.leftUp = false);

            // Left paddle down
            leftDown.addEventListener('touchstart', () => touchState.leftDown = true);
            leftDown.addEventListener('touchend', () => touchState.leftDown = false);
            leftDown.addEventListener('touchcancel', () => touchState.leftDown = false);

            // Right paddle up
            rightUp.addEventListener('touchstart', () => touchState.rightUp = true);
            rightUp.addEventListener('touchend', () => touchState.rightUp = false);
            rightUp.addEventListener('touchcancel', () => touchState.rightUp = false);

            // Right paddle down
            rightDown.addEventListener('touchstart', () => touchState.rightDown = true);
            rightDown.addEventListener('touchend', () => touchState.rightDown = false);
            rightDown.addEventListener('touchcancel', () => touchState.rightDown = false);

            // Also support mouse events for testing
            leftUp.addEventListener('mousedown', () => touchState.leftUp = true);
            leftUp.addEventListener('mouseup', () => touchState.leftUp = false);
            leftDown.addEventListener('mousedown', () => touchState.leftDown = true);
            leftDown.addEventListener('mouseup', () => touchState.leftDown = false);
            rightUp.addEventListener('mousedown', () => touchState.rightUp = true);
            rightUp.addEventListener('mouseup', () => touchState.rightUp = false);
            rightDown.addEventListener('mousedown', () => touchState.rightDown = true);
            rightDown.addEventListener('mouseup', () => touchState.rightDown = false);

            // Tap canvas to start/pause on mobile
            canvas.addEventListener('click', () => {
                if (!gameStarted) {
                    startGame();
                } else if (gameOverDisplay.classList.contains('show')) {
                    resetGame();
                } else {
                    gameRunning = !gameRunning;
                }
            });
        }

        setupTouchControls();

        // Start game
        function startGame() {
            gameStarted = true;
            gameRunning = true;
            resetBall(true);  // Full reset on game start
        }

        // Reset game
        function resetGame() {
            leftPoints = 0;
            rightPoints = 0;
            leftGames = 0;
            rightGames = 0;
            updateScore();
            gameOverDisplay.classList.remove('show');
            gameRunning = true;
            resetBall(true);  // Full reset on game restart
        }

        // Reset ball (keeps current speed unless fullReset is true)
        function resetBall(fullReset = false) {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;

            // Only reset speed on full game reset, not between points
            if (fullReset) {
                ball.speed = initialSpeed;
            }

            // Random direction
            const angle = (Math.random() * Math.PI / 2) - Math.PI / 4; // -45 to 45 degrees
            const direction = Math.random() > 0.5 ? 1 : -1;
            ball.dx = Math.cos(angle) * ball.speed * direction;
            ball.dy = Math.sin(angle) * ball.speed;
        }

        // Update racquet positions
        function updateRacquets() {
            // Left racquet (W/S keys or touch controls)
            if ((keys['w'] || touchState.leftUp) && leftRacquet.y > 0) {
                leftRacquet.y -= racquetSpeed;
            }
            if ((keys['s'] || touchState.leftDown) && leftRacquet.y < canvas.height - racquetHeight) {
                leftRacquet.y += racquetSpeed;
            }

            // Right racquet (P/L keys or touch controls)
            if ((keys['p'] || touchState.rightUp) && rightRacquet.y > 0) {
                rightRacquet.y -= racquetSpeed;
            }
            if ((keys['l'] || touchState.rightDown) && rightRacquet.y < canvas.height - racquetHeight) {
                rightRacquet.y += racquetSpeed;
            }
        }

        // Update ball position
        function updateBall() {
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Add spin/rotation effect - faster spin at higher speeds
            ball.rotation += 0.15 + (ball.speed / 100);

            // Top and bottom collision
            if (ball.y - ballRadius <= 0 || ball.y + ballRadius >= canvas.height) {
                ball.dy *= -1;
                playSound(440, 0.1);
            }

            // Left racquet collision
            if (ball.x - ballRadius <= leftRacquet.x + leftRacquet.width &&
                ball.x >= leftRacquet.x &&
                ball.y >= leftRacquet.y &&
                ball.y <= leftRacquet.y + leftRacquet.height) {

                // Calculate hit position (-1 to 1)
                const hitPos = ((ball.y) - (leftRacquet.y + racquetHeight / 2)) / (racquetHeight / 2);
                const angle = hitPos * Math.PI / 4; // Max 45 degrees

                // Gradually increase speed with each hit
                ball.speed = Math.min(ball.speed + speedIncrement, maxSpeed);
                ball.dx = Math.cos(angle) * ball.speed;
                ball.dy = Math.sin(angle) * ball.speed;
                ball.x = leftRacquet.x + leftRacquet.width + ballRadius;

                playRacquetHitSound();
            }

            // Right racquet collision
            if (ball.x + ballRadius >= rightRacquet.x &&
                ball.x <= rightRacquet.x + rightRacquet.width &&
                ball.y >= rightRacquet.y &&
                ball.y <= rightRacquet.y + rightRacquet.height) {

                const hitPos = ((ball.y) - (rightRacquet.y + racquetHeight / 2)) / (racquetHeight / 2);
                const angle = hitPos * Math.PI / 4;

                // Gradually increase speed with each hit
                ball.speed = Math.min(ball.speed + speedIncrement, maxSpeed);
                ball.dx = -Math.cos(angle) * ball.speed;
                ball.dy = Math.sin(angle) * ball.speed;
                ball.x = rightRacquet.x - ballRadius;

                playRacquetHitSound();
            }

            // Score points
            if (ball.x < 0) {
                scorePoint('right');
            }

            if (ball.x > canvas.width) {
                scorePoint('left');
            }
        }

        // Tennis scoring logic
        function scorePoint(player) {
            if (player === 'left') {
                leftPoints++;
            } else {
                rightPoints++;
            }

            // Show taunt when someone scores
            if (Math.random() > 0.4) {
                showDistraction();
            }

            // Check for game win
            if (leftPoints >= 4 || rightPoints >= 4) {
                // Deuce situation
                if (leftPoints === rightPoints) {
                    // Deuce - continue playing
                } else if (leftPoints >= rightPoints + 2) {
                    // Left wins the game
                    leftGames++;
                    leftPoints = 0;
                    rightPoints = 0;
                    playSound(660, 0.5);

                    if (leftGames >= winningGames) {
                        endGame('LEFT PLAYER WINS THE MATCH!', 'right');
                        return;
                    }
                } else if (rightPoints >= leftPoints + 2) {
                    // Right wins the game
                    rightGames++;
                    leftPoints = 0;
                    rightPoints = 0;
                    playSound(660, 0.5);

                    if (rightGames >= winningGames) {
                        endGame('RIGHT PLAYER WINS THE MATCH!', 'left');
                        return;
                    }
                }
            }

            updateScore();
            playSound(200, 0.3);
            resetBall();
        }

        // Update score display with tennis scoring
        function updateScore() {
            let leftDisplay, rightDisplay;

            // Check for deuce/advantage
            if (leftPoints >= 3 && rightPoints >= 3) {
                if (leftPoints === rightPoints) {
                    leftDisplay = 'DEUCE';
                    rightDisplay = '';
                } else if (leftPoints > rightPoints) {
                    leftDisplay = 'AD';
                    rightDisplay = '';
                } else {
                    leftDisplay = '';
                    rightDisplay = 'AD';
                }
            } else {
                leftDisplay = getTennisScore(leftPoints);
                rightDisplay = getTennisScore(rightPoints);
            }

            // Display format: "Games | Points - Points | Games"
            if (leftDisplay === 'DEUCE') {
                scoreDisplay.textContent = `${leftGames} | DEUCE | ${rightGames}`;
            } else if (leftDisplay === 'AD') {
                scoreDisplay.textContent = `${leftGames} | ADV - | ${rightGames}`;
            } else if (rightDisplay === 'AD') {
                scoreDisplay.textContent = `${leftGames} | - ADV | ${rightGames}`;
            } else {
                scoreDisplay.textContent = `${leftGames} | ${leftDisplay} - ${rightDisplay} | ${rightGames}`;
            }
        }

        // End game
        function endGame(message, loser) {
            gameRunning = false;
            const pickleballTaunt = loser === 'left'
                ? '\n\nLeft Player: Go play pickleball instead! ðŸ¥’'
                : '\n\nRight Player: Go play pickleball instead! ðŸ¥’';
            winnerText.innerHTML = message + '<br><br>' +
                '<span style="font-size: 24px; color: #DFFF00;">' +
                (loser === 'left' ? 'LEFT' : 'RIGHT') + ' PLAYER: Go play pickleball instead! ðŸ¥’</span>';
            gameOverDisplay.classList.add('show');
            playSound(330, 0.5);
        }

        // Draw tennis racquet
        function drawRacquet(x, y, width, height) {
            // Racquet frame (oval)
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.ellipse(x + width/2, y + height/2, width/2, height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // String pattern
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(x + (i * width/4), y);
                ctx.lineTo(x + (i * width/4), y + height);
                ctx.stroke();
            }
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y + (i * height/7));
                ctx.lineTo(x + width, y + (i * height/7));
                ctx.stroke();
            }
        }

        // Draw tennis ball with realistic texture
        function drawTennisBall(x, y, radius) {
            // Main ball (yellow-green)
            ctx.fillStyle = '#DFFF00';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Shadow/shading
            const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Curved seam lines
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.7, ball.rotation, ball.rotation + Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.7, ball.rotation + Math.PI, ball.rotation + Math.PI * 2);
            ctx.stroke();
        }

        // Draw everything
        function draw() {
            // Clear canvas with tennis court green
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw court lines (white)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;

            // Center net line
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            // Service boxes (decorative)
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);

            // Draw racquets
            drawRacquet(leftRacquet.x, leftRacquet.y, leftRacquet.width, leftRacquet.height);
            drawRacquet(rightRacquet.x, rightRacquet.y, rightRacquet.width, rightRacquet.height);

            // Draw tennis ball
            drawTennisBall(ball.x, ball.y, ballRadius);

            // Draw start message
            if (!gameStarted) {
                ctx.fillStyle = '#fff';
                ctx.font = '36px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('PRESS SPACE TO START', canvas.width / 2, canvas.height / 2);
            } else if (!gameRunning && !gameOverDisplay.classList.contains('show')) {
                ctx.fillStyle = '#fff';
                ctx.font = '36px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        // Tennis racquet hit sound - realistic "thwack" sound
        function playRacquetHitSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create noise for the "thwack" impact
                const bufferSize = audioContext.sampleRate * 0.05; // 50ms
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);

                // Generate noise with envelope
                for (let i = 0; i < bufferSize; i++) {
                    const envelope = Math.exp(-i / (bufferSize * 0.2)); // Sharp decay
                    data[i] = (Math.random() * 2 - 1) * envelope;
                }

                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;

                // Add some tonal content (string vibration)
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.value = 150 + Math.random() * 100; // Vary pitch slightly
                oscillator.type = 'triangle';

                // Create filters for racquet resonance
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 2000;
                noiseFilter.Q.value = 2;

                const toneFilter = audioContext.createBiquadFilter();
                toneFilter.type = 'lowpass';
                toneFilter.frequency.value = 400;

                // Gain nodes
                const noiseGain = audioContext.createGain();
                noiseGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

                const toneGain = audioContext.createGain();
                toneGain.gain.setValueAtTime(0.15, audioContext.currentTime);
                toneGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);

                // Connect everything
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(audioContext.destination);

                oscillator.connect(toneFilter);
                toneFilter.connect(toneGain);
                toneGain.connect(audioContext.destination);

                // Play
                noise.start(audioContext.currentTime);
                noise.stop(audioContext.currentTime + 0.05);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.08);
            } catch (e) {
                // Sound failed, continue without it
            }
        }

        // Simple beep sound using Web Audio API
        function playSound(frequency, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'square';

                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Sound failed, continue without it
            }
        }

        // Game loop
        function gameLoop() {
            if (gameRunning) {
                updateRacquets();
                updateBall();

                // Random chance to show distraction during gameplay
                if (Math.random() < 0.003) { // ~18% chance per second at 60fps
                    showDistraction();
                }
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        gameLoop();
    </script>
</body>
</html>
